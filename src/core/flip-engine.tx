import { FlipOptions } from '../types';

export class FlipSensorCard extends HTMLElement {
  private content: HTMLElement | null = null;
  private config: Partial<FlipOptions> = {};
  private currentDisplayValue: string[] = [];
  private lastState: string = '';
  private isDemoRunning = false;
  
  // Parametry animacji
  private drumChars = [' ', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '.', ',', ':', '%', '°', 'k', 'm', 'h', 'V', 'W', 'A'];
  private normalSpeed = 0.6;
  private spinSpeed = 0.12;
  private removeSpeed = 0.5;
  
  // Style Themes (uproszczone mapowanie, pełne style przejmie CSS-in-JS w React)
  private themes: Record<string, any> = {
    'classic': { font: "'Oswald', sans-serif" },
    'neon': { font: "'Courier New', monospace" },
  };

  constructor() {
    super();
    this.attachShadow({ mode: 'open' });
  }

  // Metoda wywoływana przez Reacta
  public setConfig(config: FlipOptions) {
    this.config = config;
    this.normalSpeed = config.speed || 0.6;
    
    // Jeśli komponent już istnieje, przerysuj go przy zmianie konfigu
    if (this.content) {
      this.render();
      if (this.lastState) {
        this.updateDisplay(this.lastState, true);
      }
    }
  }

  public setValue(value: any, unitFromData: string) {
    const val = value !== undefined && value !== null ? String(value) : "";
    let displayString = val;
    
    // Prosta obsługa jednostki wewnątrz stringa (opcja 'none')
    if (this.config.unitPos === 'none' && unitFromData) {
      displayString += unitFromData;
    }

    if (!this.content) {
      this.render();
      this.updateDisplay(displayString, true);
      this.lastState = displayString;
    } else if (displayString !== this.lastState) {
      this.lastState = displayString;
      this.updateDisplay(displayString, false);
    }
  }

  private render() {
    if (!this.shadowRoot) return;
    
    // Pobieramy font w zależności od motywu, ale style kolorów przyjdą z zewnątrz (CSS vars)
    const font = this.themes[this.config.theme || 'classic']?.font || 'sans-serif';

    this.shadowRoot.innerHTML = `
      <style>
        :host { 
            display: block; 
            --card-size: ${this.config.cardSize || 40}px; 
            --card-width: calc(var(--card-size) * 0.70); 
            --font-size: calc(var(--card-size) * 0.85); 
            --flip-duration: 0.5s;
        }
        .flip-clock { 
            display: flex; 
            justify-content: center; 
            gap: ${this.config.gap || 4}px; 
            perspective: 1000px; 
            font-family: ${font};
        }
        
        .flip-unit { 
            position: relative; 
            width: var(--card-width);
            height: var(--card-size); 
            background: var(--flip-bg, #333); 
            color: var(--flip-text, #fff);
            border-radius: 4px; 
            font-weight: bold; 
            font-size: var(--font-size); 
            line-height: var(--card-size); 
            text-align: center; 
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
        }
        
        .top, .bottom, .flap { position: absolute; left: 0; width: 100%; height: 50%; overflow: hidden; background: inherit; backface-visibility: hidden; }
        .top { top: 0; border-radius: 4px 4px 0 0; border-bottom: 1px solid rgba(0,0,0,0.3); z-index: 1; }
        .bottom { bottom: 0; border-radius: 0 0 4px 4px; z-index: 0; }
        .flap.front { top: 0; transform-origin: bottom; border-radius: 4px 4px 0 0; border-bottom: 1px solid rgba(0,0,0,0.3); z-index: 2; }
        .flap.back { top: 50%; transform-origin: top; border-radius: 0 0 4px 4px; transform: rotateX(180deg); z-index: 3; }
        
        .top::before, .bottom::before, .flap::before { content: attr(data-val); position: absolute; left: 0; width: 100%; height: 200%; }
        .top::before, .flap.front::before { top: 0; } .bottom::before, .flap.back::before { top: -100%; }
        
        .flip-unit.flipping .flap.front { animation: flipDownFront var(--flip-duration) ease-in forwards; }
        .flip-unit.flipping .flap.back { animation: flipDownBack var(--flip-duration) ease-out forwards; }
        
        @keyframes flipDownFront { 0% { transform: rotateX(0deg); } 100% { transform: rotateX(-180deg); } }
        @keyframes flipDownBack { 0% { transform: rotateX(180deg); } 100% { transform: rotateX(0deg); } }
      </style>

      <div id="display" class="flip-clock"></div>
    `;
    this.content = this.shadowRoot.getElementById('display') as HTMLElement;
  }

  private createDigitUnit(char: string): HTMLElement {
    const unit = document.createElement('div');
    unit.className = 'flip-unit';
    unit.innerHTML = `
      <div class="top" data-val="${char}"></div>
      <div class="bottom" data-val="${char}"></div>
      <div class="flap front" data-val="${char}"></div>
      <div class="flap back" data-val="${char}"></div>
    `;
    return unit;
  }

  private async updateDisplay(inputRaw: string, skipAnimation: boolean) {
    if (!this.content) return;
    const input = String(inputRaw);
    const targetLen = Math.max(input.length, this.config.digitCount || 4);
    
    // Dodawanie brakujących kafelków
    while (this.content.children.length < targetLen) {
        const blank = this.createDigitUnit(' ');
        this.content.insertBefore(blank, this.content.firstChild);
        this.currentDisplayValue.unshift(' ');
    }

    const paddedInput = input.padStart(targetLen, ' ');
    const targetChars = paddedInput.split('');
    const units = Array.from(this.content.children) as HTMLElement[];

    if (skipAnimation) {
        targetChars.forEach((char, i) => {
            if(units[i]) {
                this.updateStatic(units[i], char);
                this.currentDisplayValue[i] = char;
            }
        });
        return;
    }

    const promises = targetChars.map((targetChar, index) => {
      const unit = units[index];
      if (!unit) return Promise.resolve();

      const currentChar = this.currentDisplayValue[index] || ' ';
      if (currentChar === targetChar) return Promise.resolve();

      return this.spinDigit(unit, currentChar, targetChar, index);
    });

    await Promise.all(promises);
  }

  private updateStatic(unit: HTMLElement, char: string) {
    const setVal = (sel: string) => unit.querySelector(sel)?.setAttribute('data-val', char);
    setVal('.top'); setVal('.bottom'); setVal('.flap.front'); setVal('.flap.back');
  }

  private async spinDigit(element: HTMLElement, startChar: string, endChar: string, index: number) {
    let current = startChar;
    let safety = 0;
    
    // Logika wyboru kierunku/dystansu
    let startIndex = this.drumChars.indexOf(startChar);
    let endIndex = this.drumChars.indexOf(endChar);
    if (startIndex === -1) startIndex = 0;
    if (endIndex === -1) endIndex = 0;
    
    // Jeśli znaku nie ma na bębnie, po prostu podmień statycznie (safety fallback)
    if (!this.drumChars.includes(endChar)) {
        this.updateStatic(element, endChar);
        this.currentDisplayValue[index] = endChar;
        return;
    }

    while (current !== endChar && safety < 30) {
      let idx = this.drumChars.indexOf(current);
      let nextIdx = (idx + 1) % this.drumChars.length;
      let nextChar = this.drumChars[nextIdx];
      
      await this.flipOnce(element, current, nextChar, 0.12); // Speed hardcoded for demo
      current = nextChar;
      this.currentDisplayValue[index] = current;
      safety++;
    }
  }

  private flipOnce(element: HTMLElement, oldChar: string, newChar: string, duration: number) {
    return new Promise<void>(resolve => {
        const top = element.querySelector('.top');
        const bottom = element.querySelector('.bottom');
        const flapFront = element.querySelector('.flap.front');
        const flapBack = element.querySelector('.flap.back');
        if(!top || !bottom || !flapFront || !flapBack) { resolve(); return; }

        element.style.setProperty('--flip-duration', duration + 's');
        top.setAttribute('data-val', newChar);
        bottom.setAttribute('data-val', oldChar);
        flapFront.setAttribute('data-val', oldChar);
        flapBack.setAttribute('data-val', newChar);

        element.classList.remove('flipping');
        void element.offsetWidth; // Trigger reflow
        element.classList.add('flipping');

        setTimeout(() => {
            bottom.setAttribute('data-val', newChar);
            flapFront.setAttribute('data-val', newChar);
            element.classList.remove('flipping');
            resolve();
        }, duration * 1000);
    });
  }
}

// Rejestracja Web Componentu
if (!customElements.get('flip-sensor-card')) {
  customElements.define('flip-sensor-card', FlipSensorCard);
}


